package com.example.hi_tech_controls.ui.activity;

import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.recyclerview.widget.DefaultItemAnimator;
import androidx.recyclerview.widget.RecyclerView.ItemAnimator;

import com.example.hi_tech_controls.R;
import com.example.hi_tech_controls.adapter.AddDetailsAdp;
import com.example.hi_tech_controls.helper.OfflineSyncManager;
import com.example.hi_tech_controls.helper.PermissionUtils;
import com.example.hi_tech_controls.model.DetailsModel;
import com.facebook.shimmer.ShimmerFrameLayout;
import com.google.android.gms.tasks.Task;
import com.google.android.gms.tasks.Tasks;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.ListenerRegistration;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QuerySnapshot;
import com.google.firebase.firestore.Source;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import cn.pedant.SweetAlert.SweetAlertDialog;

/**
 * Optimized, lifecycle-safe MainActivity with professional animations and bug fixes.
 *
 * Fix applied (bug #X): avoid applying `!= null` to primitive int. Map keys are now only added
 * when the model's UID is not null to prevent accidental NullPointer/invalid key usage.
 *
 * Added UI polish:
 *  - RecyclerView layout animation: slide-in + fade (staggered)
 *  - Default item animator retained (smooth add/remove)
 *  - Shimmer → list cross-fade handled by view visibility + animations
 */
public class MainActivity extends BaseActivity {

    private static final String TAG = "MainActivity";
    private static final int PAGE_LIMIT = 150;

    private RecyclerView recyclerViewDiscovery1;
    private AddDetailsAdp addDetailsAdapter;
    private CollectionReference collectionRef;
    private ListenerRegistration realtimeListener;

    private ShimmerFrameLayout shimmerLayout;
    private TextView emptyView;
    private Button addClientBtn1, viewClientBtn1;
    private ImageView logoutBtn, refreshButton;

    // State
    private volatile boolean isListenerActive = false;
    private volatile boolean slowToastShown = false;
    private volatile boolean isLoadingMore = false;

    private DocumentSnapshot lastDoc = null;
    private Toast currentToast;

    // Background pools
    private final ExecutorService backgroundPool = Executors.newFixedThreadPool(4);
    private final ScheduledExecutorService slowNetworkScheduler = Executors.newSingleThreadScheduledExecutor();
    private ScheduledFuture<?> slowNoticeFuture;
    private int lastListSize = 0;

    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (!checkLoginStatus()) return;

        setContentView(R.layout.activity_main);

        requestPermissionsIfNeeded();
        bindViews();
        setupRecyclerView();
        setupFirestoreReference();
        setupClickListeners();

        showShimmer();
        loadInitialData();
        setupScrollPagination();
    }

    @Override
    protected void onResume() {
        super.onResume();
        startRealtimeListener();
    }

    @Override
    protected void onPause() {
        stopRealtimeListener();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        stopRealtimeListener();
        try { backgroundPool.shutdownNow(); } catch (Exception ignored) {}
        try { if (slowNoticeFuture != null) slowNoticeFuture.cancel(true); } catch (Exception ignored) {}
        try { slowNetworkScheduler.shutdownNow(); } catch (Exception ignored) {}
        super.onDestroy();
    }

    // ---------------------------
    // Login check + setup
    // ---------------------------
    private boolean checkLoginStatus() {
        boolean logged = getSharedPreferences("Login", MODE_PRIVATE)
                .getBoolean("flag", false);
        if (!logged) {
            startActivity(new Intent(this, LoginActivity.class));
            finish();
            return false;
        }
        return true;
    }

    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
    private void requestPermissionsIfNeeded() {
        if (!PermissionUtils.hasStoragePermissions(this)) {
            PermissionUtils.requestStoragePermissions(this, 1001);
        }
    }

    private void bindViews() {
        addClientBtn1 = findViewById(R.id.addClientBtn);
        viewClientBtn1 = findViewById(R.id.viewClientBtn);
        logoutBtn = findViewById(R.id.logout_btn);
        refreshButton = findViewById(R.id.refreshButton);
        recyclerViewDiscovery1 = findViewById(R.id.recyclerViewDiscovery);
        shimmerLayout = findViewById(R.id.shimmerLayout);
        emptyView = findViewById(R.id.emptyView);
    }

    private void setupRecyclerView() {
        recyclerViewDiscovery1.setLayoutManager(new LinearLayoutManager(this));
        recyclerViewDiscovery1.setHasFixedSize(true);

        // Adapter (assumed DiffUtil-backed for submitList)
        addDetailsAdapter = new AddDetailsAdp(this, new ArrayList<>());
        recyclerViewDiscovery1.setAdapter(addDetailsAdapter);

        // Smooth default animations
        ItemAnimator animator = new DefaultItemAnimator();
        animator.setAddDuration(200);
        animator.setRemoveDuration(180);
        recyclerViewDiscovery1.setItemAnimator(animator);

        // Prepare a professional layout animation (slide-in + slight fade) to run when list updates
        Animation slideIn = AnimationUtils.loadAnimation(this, android.R.anim.slide_in_left);
        // tweak duration so it's subtle and professional
        slideIn.setDuration(260);
        final android.view.animation.LayoutAnimationController controller =
                new android.view.animation.LayoutAnimationController(slideIn, 0.08f);
        controller.setOrder(android.view.animation.LayoutAnimationController.ORDER_NORMAL);

        // Attach once; we'll call scheduleLayoutAnimation() after submitList to play it.
        recyclerViewDiscovery1.setLayoutAnimation(controller);
    }

    private void setupFirestoreReference() {
        FirebaseFirestore db = FirebaseFirestore.getInstance();
        collectionRef = db.collection("hi_tech_controls_dataset_JUNE");
    }

    private void setupClickListeners() {
        addClientBtn1.setOnClickListener(v -> startActivity(new Intent(this, AddDetailsActivity.class)));
        viewClientBtn1.setOnClickListener(v -> startActivity(new Intent(this, ViewDetailsActivity.class)));
        refreshButton.setOnClickListener(v -> refreshData());
        logoutBtn.setOnClickListener(v -> showLogoutDialog());
    }

    // ---------------------------
    // Data flow (cache -> server -> realtime)
    // ---------------------------
    private void loadInitialData() {
        Query q = collectionRef.orderBy("clientId", Query.Direction.DESCENDING).limit(PAGE_LIMIT);
        loadCache(q);
        loadFromServer(q);
    }

    private void loadCache(Query q) {
        q.get(Source.CACHE)
                .addOnSuccessListener(cached -> {
                    if (cached != null && !cached.isEmpty()) {
                        applySnapshotSafely(cached.getDocuments(), false);
                        crossfadeShimmerToList();
                    }
                })
                .addOnFailureListener(e -> Log.w(TAG, "Cache load failed: " + e.getMessage()));
    }

    private void loadFromServer(Query q) {
        q.get().addOnSuccessListener(snap -> {
            if (snap != null && !snap.isEmpty()) {
                lastDoc = snap.getDocuments().get(snap.size() - 1);
            }
            applySnapshotSafely(snap == null ? null : snap.getDocuments(), false);
            crossfadeShimmerToList();
            startRealtimeListener();
        }).addOnFailureListener(e -> {
            crossfadeShimmerToList();
            showToast("Load failed: " + e.getMessage());
        });
    }

    // ---------------------------
    // Realtime listener + slow network notice
    // ---------------------------
    private void startRealtimeListener() {
        if (isListenerActive) return;
        isListenerActive = true;

        scheduleSlowNetworkNotice();

        realtimeListener = collectionRef.addSnapshotListener((snapshots, e) -> {
            if (!isListenerActive) return;
            if (e != null) {
                Log.e(TAG, "Realtime error: " + e.getMessage());
                return;
            }
            if (snapshots == null) return;

            // fast response — cancel slow notice
            cancelSlowNetworkNotice();

            applySnapshotSafely(snapshots.getDocuments(), true);
        });
    }

    private void stopRealtimeListener() {
        isListenerActive = false;
        cancelSlowNetworkNotice();
        if (realtimeListener != null) {
            try { realtimeListener.remove(); } catch (Exception ignored) {}
            realtimeListener = null;
        }
    }

    private void scheduleSlowNetworkNotice() {
        slowToastShown = false;
        // cancel previous if any
        cancelSlowNetworkNotice();
        slowNoticeFuture = slowNetworkScheduler.schedule(() -> {
            if (!slowToastShown && shimmerLayout.getVisibility() == View.VISIBLE) {
                runOnUiThread(() -> showToast("Network slow, loading..."));
                slowToastShown = true;
            }
        }, 2500, TimeUnit.MILLISECONDS);
    }

    private void cancelSlowNetworkNotice() {
        slowToastShown = true;
        try {
            if (slowNoticeFuture != null) slowNoticeFuture.cancel(true);
        } catch (Exception ignored) {}
        slowNoticeFuture = null;
    }

    // ---------------------------
    // Snapshot processing (dedupe + async name fetch)
    // ---------------------------
    private void applySnapshotSafely(List<DocumentSnapshot> docs, boolean fromRealtime) {
        if (docs == null) {
            updateList(new ArrayList<>());
            return;
        }

        // Dedupe by document ID (latest wins)
        Map<String, DocumentSnapshot> byId = new HashMap<>(docs.size());
        for (DocumentSnapshot d : docs) {
            if (d == null) continue;
            if (!isValidDoc(d)) continue;
            String id = d.getId();
            if (id == null) continue;
            byId.put(id, d);
        }

        if (byId.isEmpty()) {
            updateList(new ArrayList<>());
            return;
        }

        // Convert to models and trigger name fetches
        List<DetailsModel> models = new ArrayList<>(byId.size());
        List<Task<?>> nameTasks = new ArrayList<>();

        for (DocumentSnapshot doc : byId.values()) {
            DetailsModel m = parseDocument(doc);
            models.add(m);
            nameTasks.add(fetchNameAsync(doc, m));
        }

        if (nameTasks.isEmpty()) {
            updateList(models);
            return;
        }

        Tasks.whenAllComplete(nameTasks).addOnCompleteListener(t -> updateList(models));
    }

    // ---------------------------
    // UI update + animation
    // ---------------------------
    private void updateList(List<DetailsModel> items) {

        // Sorting logic
        Collections.sort(items, (a, b) -> {
            boolean aDone = a.getProgress() == 100;
            boolean bDone = b.getProgress() == 100;

            if (aDone != bDone) return aDone ? 1 : -1;

            Integer ai = a.getUId(), bi = b.getUId();
            if (ai == null && bi == null) return 0;
            if (ai == null) return 1;
            if (bi == null) return -1;

            return Integer.compare(bi, ai);
        });

        runOnUiThread(() -> {

            int newSize = items.size();
            boolean newItemsAdded = newSize > lastListSize;   // <-- IMPORTANT RULE

            addDetailsAdapter.submitList(new ArrayList<>(items));

            // Animate only when new items appear
            if (newItemsAdded) {
                try {
                    recyclerViewDiscovery1.scheduleLayoutAnimation();
                } catch (Exception ignored) {}
            }

            lastListSize = newSize; // always update

            toggleEmptyState(items.isEmpty());
        });
    }

    private void toggleEmptyState(boolean empty) {
        emptyView.setVisibility(empty ? View.VISIBLE : View.GONE);
        recyclerViewDiscovery1.setVisibility(empty ? View.GONE : View.VISIBLE);
    }

    // Cross-fade shimmer -> list with a subtle animation
    private void crossfadeShimmerToList() {
        runOnUiThread(() -> {
            try {
                // fade out shimmer quickly, then show list
                Animation fadeOut = AnimationUtils.loadAnimation(this, android.R.anim.fade_out);
                fadeOut.setDuration(220);
                shimmerLayout.startAnimation(fadeOut);
            } catch (Exception ignored) {}
            hideShimmer();
        });
    }

    // ---------------------------
    // Pagination
    // ---------------------------
    private void setupScrollPagination() {
        recyclerViewDiscovery1.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrolled(@NonNull RecyclerView rv, int dx, int dy) {
                if (!rv.canScrollVertically(1)) {
                    loadMore();
                }
            }
        });
    }

    private void loadMore() {
        if (isLoadingMore || lastDoc == null) return;
        isLoadingMore = true;

        Query q = collectionRef.orderBy("clientId", Query.Direction.DESCENDING)
                .startAfter(lastDoc)
                .limit(PAGE_LIMIT);

        q.get().addOnSuccessListener(snap -> {
            if (snap != null && !snap.isEmpty()) {
                lastDoc = snap.getDocuments().get(snap.size() - 1);
                applyPaginationAppend(snap.getDocuments());
            }
            isLoadingMore = false;
        }).addOnFailureListener(e -> {
            isLoadingMore = false;
            Log.e(TAG, "Pagination failed: " + e.getMessage());
        });
    }

    private void applyPaginationAppend(List<DocumentSnapshot> docs) {
        // Merge current items into map keyed by uid (only non-null UIDs)
        Map<Integer, DetailsModel> merged = new HashMap<>();
        for (DetailsModel m : addDetailsAdapter.getCurrentItems()) {
            Integer id = m.getUId();
            if (id != null) merged.put(id, m); // BUG FIX: don't put null key
        }

        List<Task<?>> tasks = new ArrayList<>();

        for (DocumentSnapshot d : docs) {
            if (!isValidDoc(d)) continue;
            DetailsModel model = parseDocument(d);
            Integer id = model.getUId();
            if (id != null) merged.put(id, model);
            tasks.add(fetchNameAsync(d, model));
        }

        if (tasks.isEmpty()) {
            updateList(new ArrayList<>(merged.values()));
            return;
        }

        Tasks.whenAllComplete(tasks).addOnCompleteListener(t -> updateList(new ArrayList<>(merged.values())));
    }

    // ---------------------------
    // Helpers
    // ---------------------------
    private boolean isValidDoc(DocumentSnapshot doc) {
        if (doc == null) return false;
        String id = doc.getId();
        if (id == null) return false;
        return !"last_id".equals(id) && !"initialDoc".equals(id);
    }

    private DetailsModel parseDocument(DocumentSnapshot doc) {
        DetailsModel m = new DetailsModel();
        Integer uid = safeParse(doc.getId(), doc.getLong("clientId"));
        m.setUId(uid);
        Long p = doc.getLong("progress");
        m.setProgress(p != null ? p.intValue() : 0);
        m.setuName("…");
        return m;
    }

    private Task<DocumentSnapshot> fetchNameAsync(DocumentSnapshot doc, DetailsModel model) {
        // Firestore call; model is updated when result returns
        return collectionRef.document(doc.getId())
                .collection("pages").document("fill_one")
                .get()
                .addOnSuccessListener(d -> {
                    String name = d.getString("name");
                    model.setuName(name != null ? name : "Unknown");
                })
                .addOnFailureListener(err -> model.setuName("Unknown"));
    }

    private Integer safeParse(String id, Long fb) {
        try { return Integer.parseInt(id); }
        catch (Exception e) { return fb == null ? null : fb.intValue(); }
    }

    private void refreshData() {
        stopRealtimeListener();
        lastDoc = null;
        addDetailsAdapter.submitList(new ArrayList<>());
        showShimmer();
        loadInitialData();
    }

    private void showShimmer() {
        shimmerLayout.setVisibility(View.VISIBLE);
        shimmerLayout.startShimmer();
        recyclerViewDiscovery1.setVisibility(View.GONE);
        emptyView.setVisibility(View.GONE);
    }

    private void hideShimmer() {
        try { shimmerLayout.stopShimmer(); } catch (Exception ignored) {}
        shimmerLayout.setVisibility(View.GONE);
        recyclerViewDiscovery1.setVisibility(View.VISIBLE);
    }

    private void showLogoutDialog() {
        new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE)
                .setTitleText("Logout")
                .setContentText("Are you sure you want to logout?")
                .setConfirmButtonBackgroundColor(Color.parseColor("#FF0000"))
                .setCancelButtonBackgroundColor(Color.parseColor("#7C7C7C"))
                .setConfirmText("Logout")
                .setCancelText("Cancel")
                .setConfirmClickListener(s -> {
                    logout();
                    s.dismissWithAnimation();
                })
                .showCancelButton(true)
                .show();
    }

    private void logout() {
        SharedPreferences preferences = getSharedPreferences("Login", MODE_PRIVATE);
        preferences.edit().putBoolean("flag", false).apply();

        Intent i = new Intent(this, LoginActivity.class);
        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        startActivity(i);
        finish();
    }

    private void showToast(String msg) {
        if (currentToast != null) currentToast.cancel();
        currentToast = Toast.makeText(this, msg, Toast.LENGTH_SHORT);
        currentToast.show();
    }

    @Override
    public void onBackPressed() {
        boolean flag = getSharedPreferences("Login", MODE_PRIVATE)
                .getBoolean("flag", false);
        if (flag) showLogoutDialog();
        else super.onBackPressed();
    }

    @Override
    protected void onNetworkStateChanged(boolean isOnline) {
        if (isOnline) OfflineSyncManager.getInstance().syncNow(this);
    }
}
